import markdown
import re
import urllib.parse

from fastapi import FastAPI, Request, Form, Depends, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from starlette.status import HTTP_401_UNAUTHORIZED
from sentence_transformers import SentenceTransformer
from pydantic import BaseModel
import chromadb
import openai
import os
import secrets
import csv
from dotenv import load_dotenv
from fulltext_validator import analyzuj_relevantni_banky_fulltextem

import re
from collections import defaultdict

def agreguj_banky_v_odpovedi(odpoved_markdown):
    """
    Najde v≈°echny bloky typu "### üè¶ N√°zev banky" ... a≈æ do dal≈°√≠ banky nebo konce.
    Slije Podm√≠nky a Citace od stejn√© banky do jednoho spoleƒçn√©ho bloku.
    """
    banky = defaultdict(list)

    # Najdi bloky od ### üè¶ a≈æ po dal≈°√≠ ### üè¶ nebo konec
    pattern = r"(### üè¶[^\n]+(?:\n.*?)+?)(?=\n### üè¶|\Z)"
    for blok in re.findall(pattern, odpoved_markdown, flags=re.DOTALL):
        # N√°zev banky
        nazev_match = re.match(r"### üè¶\s*([^\n]+)", blok)
        if not nazev_match:
            continue
        banka = nazev_match.group(1).strip()

        # Oddƒõl√≠me "Podm√≠nky", "Dolo≈æen√≠" apod. a citace
        podminky = []
        citace = []
        lines = blok.split("\n")
        for line in lines[1:]:  # [1:] proto≈æe [0] je n√°zev banky
            # Pokud je to citace, schov√°me ji
            if line.strip().startswith("üìÑ Citace:"):
                citace.append(line.strip())
            # Ostatn√≠ nech√°me jako podm√≠nky (vƒçetnƒõ p≈ô√≠padn√Ωch ‚ÄûDolo≈æen√≠‚Äú atd.)
            elif line.strip():
                podminky.append(line.rstrip())
        # Ulo≈æ√≠me do dictu
        banky[banka].append({
            "podminky": podminky,
            "citace": citace
        })

    # Fin√°ln√≠ sl√©v√°n√≠ ‚Äì pro ka≈ædou banku vypi≈° v≈°echny podm√≠nky i citace
    vystup = []
    for banka, bloky in banky.items():
        vystup.append(f"### üè¶ {banka}")
        vsechny_podminky = []
        vsechny_citace = []
        for blok in bloky:
            vsechny_podminky.extend(blok["podminky"])
            vsechny_citace.extend(blok["citace"])
        # Odstran√≠me duplicitn√≠ ≈ô√°dky (zachov√° po≈ôad√≠)
        podminky_unique = []
        for p in vsechny_podminky:
            if p not in podminky_unique:
                podminky_unique.append(p)
        citace_unique = []
        for c in vsechny_citace:
            if c not in citace_unique:
                citace_unique.append(c)
        vystup.extend(podminky_unique)
        vystup.extend(citace_unique)
        vystup.append("")  # mezera mezi bankami
    return "\n".join(vystup).strip()


# Slovn√≠k p≈ôevod≈Ø v≈°ech mo≈æn√Ωch n√°zv≈Ø na ofici√°ln√≠ n√°zev banky:
BANK_NAME_MAP = {
    "komercnibanka": "Komerƒçn√≠ banka",
    "kb": "Komerƒçn√≠ banka",
    "ceskasporitelna": "ƒåesk√° spo≈ôitelna",
    "cs": "ƒåesk√° spo≈ôitelna",
    "csob": "ƒåSOB Hypoteƒçn√≠ banka",
    "csobhypotecnibanka": "ƒåSOB Hypoteƒçn√≠ banka",
    "mbank": "mBank",
    "oberbank": "Oberbank AG",
    "oberbankag": "Oberbank AG",
    "unicreditbank": "UniCredit Bank",
    "ucb": "UniCredit Bank",
    "raiffeisenbank": "Raiffeisenbank",
    "rb": "Raiffeisenbank",
    # p≈ôidej dal≈°√≠ podle pot≈ôeby
}

def normalizuj_nazev_banky(banka_raw):
    import unicodedata
    if not banka_raw or "nezn√°m√°" in banka_raw.lower():
        return "Nezn√°m√° banka"
    banka = banka_raw.strip().lower()
    banka = ''.join(
        c for c in unicodedata.normalize('NFD', banka)
        if unicodedata.category(c) != 'Mn'
    )
    banka = banka.replace(" ", "")
    return BANK_NAME_MAP.get(banka, banka_raw.strip())

# --- P≈ôid√°no: zp≈ô√≠stupnƒõn√≠ modulu z root slo≈æky ---
import sys
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from fulltext_validator import analyzuj_relevantni_banky_fulltextem

# === Zv√Ωraznƒõn√≠ a prolinkov√°n√≠ citac√≠ ===
def highlight_citations(text: str) -> str:
    import re, urllib.parse

    def replace(match):
        citation = match.group(0)
        doc_match = re.search(r'dokument: ([^)]+)', citation)

        if not doc_match:
            return citation

        filename = doc_match.group(1).strip()
        safe_filename = urllib.parse.quote(filename)
        url = f"/metodiky/{safe_filename}"

        return f"<a href='{url}' target='_blank' class='citation'>{citation}</a>"

    pattern = r"\(dokument: [^)]+\)"
    return re.sub(pattern, replace, text)

# === Naƒçten√≠ .env promƒõnn√Ωch ===
load_dotenv()
USERNAME = os.getenv("APP_USERNAME")
PASSWORD = os.getenv("APP_PASSWORD")

# === Inicializace aplikace ===
app = FastAPI()
app.mount("/static", StaticFiles(directory="app/static"), name="static")
app.mount("/metodiky", StaticFiles(directory="metodiky_bank"), name="metodiky")

templates = Jinja2Templates(directory="app/templates")
security = HTTPBasic()

# === Embed model a vektorov√° DB ===
model = SentenceTransformer("intfloat/multilingual-e5-large")
client = chromadb.PersistentClient(path="./chroma_db")
collection = client.get_collection("hypoteky_all")

# === Autentizace ===
def check_auth(credentials: HTTPBasicCredentials = Depends(security)):
    if not (
        secrets.compare_digest(credentials.username, USERNAME)
        and secrets.compare_digest(credentials.password, PASSWORD)
    ):
        raise HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="P≈ô√≠stup odep≈ôen",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username

# === Model zpƒõtn√© vazby ===
class Feedback(BaseModel):
    question: str
    answer: str
    feedback: str
    comment: str = ""

@app.post("/feedback")
async def receive_feedback(data: Feedback):
    feedback_file = "feedback.csv"
    file_exists = os.path.isfile(feedback_file)

    with open(feedback_file, mode="a", encoding="cp1250", newline="") as f:
        writer = csv.writer(f)
        if not file_exists:
            writer.writerow(["question", "answer", "feedback", "comment"])
        writer.writerow([data.question, data.answer, data.feedback, data.comment])

    return JSONResponse(content={"status": "success"})

# === GET ===
@app.get("/", response_class=HTMLResponse)
def form_get(request: Request, username: str = Depends(check_auth)):
    return templates.TemplateResponse("index.html", {"request": request, "result": None})

# === POST ===
@app.post("/", response_class=HTMLResponse)
def form_post(request: Request, dotaz: str = Form(...), username: str = Depends(check_auth)):
    embedding = model.encode(f"query: {dotaz.strip()}").tolist()
    results = collection.query(query_embeddings=[embedding], n_results=80, include=["documents", "metadatas"])

    # Krok 2: p≈ô√≠prava chunk≈Ø a metadat
    relevant_chunks = results["documents"][0]
    metadatas = results["metadatas"][0]

    for i, meta in enumerate(metadatas[:3]):
        print(f"Metadata {i}: {meta}")

    # === Agregace chunk≈Ø podle banky (u≈æ ≈æ√°dn√© duplicity) ===
    banky_map = {}
    for chunk, meta in zip(relevant_chunks, metadatas):
        banka_raw = meta.get("banka", "Nezn√°m√° banka")
        banka_nazev = normalizuj_nazev_banky(banka_raw)
        if banka_nazev not in banky_map:
            banky_map[banka_nazev] = {
                "chunks": [],
                "citace": []
            }
        banky_map[banka_nazev]["chunks"].append(chunk)
        banky_map[banka_nazev]["citace"].append(
            f"(dokument: {meta.get('document_source', '?')}, strana: {meta.get('strana', '?')}, kapitola: {meta.get('kapitola', '?')})"
        )

    # === Odpovƒõdi pro ka≈ædou banku pr√°vƒõ jednou ===
    pridane_banky = set()
    odpovedi_po_bankach = []

    for banka_nazev, banka_data in banky_map.items():
        chunks_banky = banka_data["chunks"]
        citace_banky = banka_data["citace"]

        if not chunks_banky:
            continue

        # GPT prompt pro v√Ωbƒõr nejrelevantnƒõj≈°√≠ho chunku
        select_prompt = [
            {
                "role": "system",
                "content": (
                    "Jsi asistent pro v√Ωbƒõr nejrelevantnƒõj≈°√≠ho √∫ryvku textu k dan√©mu dotazu. "
                    "Dostane≈° dotaz a nƒõkolik √∫ryvk≈Ø s citacemi. Vyber jen ten jeden √∫ryvek, "
                    "kter√Ω je pro zodpovƒõzen√≠ dotazu nejrelevantnƒõj≈°√≠. Pokud je to mo≈æn√©, up≈ôednostni chunk, "
                    "kter√Ω obsahuje nejv√≠ce konkr√©tn√≠ch informac√≠ k dotazu. V odpovƒõdi vypi≈° p≈ôesnƒõ vybran√Ω √∫ryvek "
                    "a jeho citaci ve form√°tu: <chunk>\nUm√≠stƒõn√≠: <citace>."
                )
            },
            {
                "role": "user",
                "content":
                    f"Dotaz: {dotaz}\n\n√öryvky:\n\n" +
                    "\n\n".join([f"{chunk}\nUm√≠stƒõn√≠: {cit}" for chunk, cit in zip(chunks_banky, citace_banky)])
            }
        ]

        select_response = openai.chat.completions.create(
            model="gpt-4o",
            messages=select_prompt,
            temperature=0
        )
        vybrany_chunk_a_citace = select_response.choices[0].message.content.strip()

        # Hlavn√≠ prompt pro banku (z≈Øst√°v√° stejn√Ω)
        messages = [
            {
                "role": "system",
                "content": (
                    "Jsi expertn√≠ asistent na hypot√©ky a posuzov√°n√≠ bonity klient≈Ø podle intern√≠ch metodik bank.\n\n"
                        "üîç Nejprve zjisti, co je vstupem u≈æivatele:\n"
                        "1. Pokud jde o plnohodnotn√Ω dotaz, klasifikuj ho internƒõ do jedn√© z tƒõchto kategori√≠:\n"
                        "   - v√Ωƒçtov√Ω\n"
                        "   - Dotazy typu ‚Äûkter√© banky‚Ä¶‚Äú v≈ædy pova≈æuj za v√Ωƒçtov√© bez ohledu na dal≈°√≠ strukturu dotazu.\n"
                        "   - srovn√°vac√≠\n"
                        "   - faktick√Ω\n"
                        "   - podm√≠nkov√Ω\n"
                        "   - kombinovan√Ω\n"
                        "2. Pokud vstup nen√≠ √∫pln√Ωm dotazem (nap≈ô. jen fragment jako ‚Äûv√Ω≈æivn√© jako p≈ô√≠jem ≈æadatele‚Äú), logicky odvoƒè, co u≈æivatel pravdƒõpodobnƒõ zji≈°≈•uje, a pokraƒçuj podle odpov√≠daj√≠c√≠ logiky.\n"
                        "3. Pokud dotaz neobsahuje n√°zev konkr√©tn√≠ banky, agreguj odpovƒõdi nap≈ô√≠ƒç v≈°emi dostupn√Ωmi dokumenty. Nikdy se nespokojuj pouze s jedn√≠m √∫ryvkem nebo jednou bankou.\n"
                        "4. Pokud dotaz obsahuje konkr√©tn√≠ banku, pracuj prim√°rnƒõ s dokumenty t√©to banky. Ostatn√≠ dokumenty zva≈æ pouze tehdy, pokud je tato banka v√Ωslovnƒõ zm√≠nƒõna jinde nebo pokud vlastn√≠ dokument chyb√≠.\n\n"
                        "üß© Instrukce podle typu dotazu:\n"
                        "- V√Ωƒçtov√Ω: Vypi≈° ka≈ædou banku, kter√° podm√≠nku spl≈àuje. Ka≈ædou zvl√°≈°≈• se struƒçn√Ωm shrnut√≠m a citac√≠.\n"
                        "  ‚ûï Pokud m√°≈° chunk pro danou banku, ale nenach√°z√≠≈° v nƒõm p≈ô√≠mou zm√≠nku k dotazu, zva≈æ mo≈ænost odpovƒõdi zalo≈æen√© na kombinaci dotazu a n√°zvu banky. Shr≈à i nep≈ô√≠m√© nebo kontextov√© informace, pokud jsou v chunc√≠ch uvedeny.\n"
                        "  ‚ûï Pokud dotaz smƒõ≈ôuje na to, **kter√© banky nƒõco umo≈æ≈àuj√≠, akceptuj√≠, podporuj√≠, toleruj√≠ nebo zohled≈àuj√≠**, v≈ædy jej pova≈æuj za v√Ωƒçtov√Ω ‚Äì i kdy≈æ se zd√° b√Ωt podm√≠nkov√Ω nebo faktick√Ω.\n"
                        "- Srovn√°vac√≠: Porovnej hodnoty nap≈ô√≠ƒç bankami a uveƒè pouze tu nejlep≈°√≠ (nebo nƒõkolik s nejvy≈°≈°√≠ hodnotou).\n"
                        "- Faktick√Ω: Odpovƒõz p≈ôesnƒõ a s citac√≠. Pokud informace chyb√≠, napi≈° to jasnƒõ.\n"
                        "- Podm√≠nkov√Ω: Popi≈° okolnosti, za kter√Ωch situace nast√°v√°. P≈ôidej citace.\n"
                        "  ‚ûï Pokud dotaz obsahuje podm√≠nku (‚Äûpokud...‚Äú, ‚Äûza jak√Ωch podm√≠nek...‚Äú), ale c√≠l√≠ na v√≠ce subjekt≈Ø (nap≈ô. ‚Äûkter√© banky‚Äú), nejprve vyfiltruj v≈°echny relevantn√≠ banky jako ve v√Ωƒçtov√©m dotazu a pak u ka≈æd√© z nich uveƒè podm√≠nky.\n"
                        "- Kombinovan√Ω: Vyfiltruj banky spl≈àuj√≠c√≠ podm√≠nku a mezi nimi srovnej v√Ωhodnost. V√Ωsledek uveƒè jen pro ty nejlep≈°√≠.\n\n"
                        "üõë Pravidla p≈ôesnosti:\n"
                        "- Vych√°zej v√Ωhradnƒõ z √∫ryvk≈Ø z dokument≈Ø v datab√°zi (ChromaDB).\n"
                        "- Nevym√Ω≈°lej informace. Nepou≈æ√≠vej web ani obecn√© znalosti.\n"
                        "- Nep≈ôi≈ôazuj informace k bank√°m, kter√© je v√Ωslovnƒõ neuv√°dƒõj√≠.\n"
                        "- V odpovƒõdi pou≈æ√≠vej n√°zvy bank p≈ôesnƒõ dle dokument≈Ø:\n"
                        "  ‚Ä¢ Hypoteky_KB.pdf ‚Üí Komerƒçn√≠ banka\n"
                        "  ‚Ä¢ Hypoteky_mB.pdf ‚Üí mBank\n"
                        "  ‚Ä¢ Hypoteky_CS.pdf ‚Üí ƒåesk√° spo≈ôitelna\n"
                        "  ‚Ä¢ Hypoteky_ƒåSOBHB.pdf ‚Üí ƒåSOB Hypoteƒçn√≠ banka\n"
                        "  ‚Ä¢ Hypoteky_UCB.pdf ‚Üí UniCredit Bank\n"
                        "  ‚Ä¢ Hypoteky_OB.pdf ‚Üí Oberbank AG\n"
                        "  ‚Ä¢ Hypoteky_RB_bonita_podnikani.pdf ‚Üí Raiffeisenbank\n\n"
                        "‚ôªÔ∏è Zamƒõniteln√© v√Ωrazy:\n"
                        "- ‚Äûamerick√° hypot√©ka‚Äú = ‚Äûne√∫ƒçelov√Ω hypoteƒçn√≠ √∫vƒõr‚Äú = ‚Äûne√∫ƒçelov√° hypot√©ka‚Äú = ‚Äûne√∫ƒçelov√° ƒç√°st hypoteƒçn√≠ho √∫vƒõru‚Äú\n"
                        "- ‚Äû√∫ƒçelov√° hypot√©ka‚Äú nen√≠ tot√©≈æ jako ‚Äûamerick√° hypot√©ka‚Äú. Nezamƒõ≈àuj tyto pojmy.\n"
                        "  Pokud je v dotazu zm√≠nƒõna americk√° hypot√©ka, ignoruj informace o √∫ƒçelov√Ωch hypot√©k√°ch.\n\n"
                        "üìã Struktura odpovƒõdi:\n"
                        "- Pou≈æij p≈ôehledn√Ω form√°t ve stylu Markdown:\n"
                        "  ‚Ä¢ Ka≈ædou banku zaƒçni nadpisem t≈ôet√≠ √∫rovnƒõ: ### üè¶ [N√°zev banky]\n"
                        "  ‚Ä¢ Ka≈ædou ƒç√°st oznaƒç tuƒçnƒõ: **Podm√≠nky:**, **V√Ωpoƒçet:**, **Dolo≈æen√≠:** apod.\n"
                        "  ‚Ä¢ Podm√≠nky a detaily strukturovanƒõ ve formƒõ odr√°≈æek: - ...\n"
                        "  ‚Ä¢ Pokud existuje v√≠ce oblast√≠, rozdƒõl je logicky a vizu√°lnƒõ\n"
                        "  ‚Ä¢ Na konec ka≈æd√©ho bloku p≈ôidej citaci: üìÑ Citace: (dokument: <n√°zev>, strana: <ƒç√≠slo>, kapitola: <ƒç√≠slo>)\n\n"
                        "üß† Pozn√°mka:\n"
                        "- Intern√≠ √∫vahy (nap≈ô. ‚ÄûDotaz je v√Ωƒçtov√Ω‚Äú) nezobrazuj u≈æivateli.\n"
                        "- Odpovƒõƒè zaƒçni rovnou u≈æiteƒçnou informac√≠.\n"
                        "  Nap≈ô√≠klad m√≠sto:\n"
                        "  ‚ÄûDotaz je v√Ωƒçtov√Ω. U≈æivatel se pt√°, kter√© banky akceptuj√≠ v√Ω≈æivn√©...‚Äú\n"
                        "  napi≈° p≈ô√≠mo:\n"
                        "  ‚ÄûBanky, kter√© akceptuj√≠ v√Ω≈æivn√© jako p≈ô√≠jem ≈æadatele:‚Äú\n"
                )
            },
            {
                "role": "user",
                "content": f"Dotaz: {dotaz}\n\nZde je nejrelevantnƒõj≈°√≠ √∫ryvek pro banku {banka_nazev}:\n\n{vybrany_chunk_a_citace}"
            }
        ]

        response = openai.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            temperature=0
        )
        if banka_nazev in pridane_banky:
                continue
        
        odpovedi_po_bankach.append(response.choices[0].message.content)
        pridane_banky.add(banka_nazev)
        
    # Krok 5: Vytvo≈ô HTML v√Ωstup
    final_answer = "\n\n".join(odpovedi_po_bankach)
    final_answer = agreguj_banky_v_odpovedi(final_answer)   # <-- agregace blok≈Ø
    odpoved_html = markdown.markdown(highlight_citations(final_answer))

    return templates.TemplateResponse("index.html", {"request": request, "result": odpoved_html, "dotaz": dotaz})
